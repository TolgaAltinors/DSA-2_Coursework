create_sub_list (array_to_sort, start_index, end_index)

	# Choose select second to last element as pivot
    pivot_index := len(array) - 1 
    pivot       := array[pivot_index]

    (swap last 2 elements around and make the pivot the last in array)
    swap array[pivot_index] with array[end_index]

    i := start_index - 1 (set to track pivot index)

    for j := 0 to len(array) do
        if array[j] < pivot then
            swap array[i] with array[j]
            
            i := i + 1 (Move the pivot index over by one)

    swap array[i + 1] with array[end_index]

    return i + 1 (new pivot)
    
    
 quick_sort (array_to_sort, start_index, end_index)
        
    if start_index < end_index then
    
        # partition the array â€“ divide it in to sub problems
        pivot_index := call partition function (array_to_sort, start_index, end_index)

        # Sort left to the pivot index
        quicksort(array, start_index, pivot_index - 1)
        # Sort right to the pivot index
        quicksort(array, pivot_index + 1, end_index)
